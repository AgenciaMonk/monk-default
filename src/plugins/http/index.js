import axios from 'axios'
import store from '@/store'
const apiUrl = process.env.API_URL
import authService from '@/services/auth.service';
axios.defaults.baseURL = apiUrl
const token = store.getters.token ? store.getters.token.access_token : null;

axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';

if (token) {
  axios.defaults.headers.common['Authorization'] = `Bearer ${token}`
  axios.defaults.headers.post['Content-Type']    = 'application/json';
}


// Add a request interceptor
//axios.interceptors.request.use(function (config) {
//  return config
//}, function (error) {
//  return Promise.reject(error)
//});
//
//// Add a response interceptor
//axios.interceptors.response.use(function (response) {
//  return response.data
//}, function (error) {
//
//  if (401 === error.response.status && store.getters.token) {
//    authService.signout();
//  } else {
//    return Promise.reject(error);
//  }
//
//});

axios.interceptors.response.use(
  response => response.data,
  /**
   * This is a central point to handle all
   * error messages generated by HTTP
   * requests
   */
  (error) => {
    const {response} = error

    /**
     * If token is either expired, not provided or invalid
     * then redirect to login. On server side the error
     * messages can be changed on app/Providers/EventServiceProvider.php
     */
    if ([401, 400].indexOf(response.status) > -1) {
      authService.signout();
    }


//    if ([404].indexOf(response.status) > -1) {
//      store.dispatch('setMessage', {type: 'error', message: 'Deu b.o'})
//    }


//    if (isArray(response.data)) {
//      store.dispatch('setMessage', {type: 'error', message: response.data.messages})
//    } else {
//      store.dispatch('setMessage', {type: 'validation', message: response.data})
//    }
//

    return Promise.reject(error)
  }
)


//Vue.prototype.$http = axios

export default axios;
